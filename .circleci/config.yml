version: 2.1

orbs:
  aws-cli: circleci/aws-cli@4.1

executors:
  python-executor:
    docker:
      - image: cimg/python:3.11
    resource_class: medium
  docker-executor:
    docker:
      - image: cimg/base:current
    resource_class: medium

jobs:

  scan-jars-and-create-dockerfile-pr:
    executor: python-executor
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: pip install PyGithub requests
      - run:
          name: Scan JARs and create Dockerfile PR
          command: python scripts/scan_jars_and_create_pr.py
          environment:
            DOCKERFILE_PATH: workload/mfx-aggre-data-platform/custom_nifi/Dockerfile
            JARS_FOLDER: workload/mfx-aggre-data-platform/custom_nifi/jars
            TARGET_BRANCH: main
            CIRCLE_PROJECT_USERNAME: medalizaidi
            CIRCLE_PROJECT_REPONAME: nifi-jar-automation-option2
      - store_artifacts:
          path: /tmp/jar-diff-report.json
          destination: jar-diff-report

  build-and-push-image:
    executor: docker-executor
    steps:
      - checkout
      - attach_workspace:
          at: /tmp
      
      # Install Python and dependencies for JAR scanning
      - run:
          name: Install Python and dependencies
          command: |
            sudo apt-get update
            sudo apt-get install -y python3 python3-pip
            pip3 install requests
      
      # Scan JARs and dynamically update Dockerfile before build
      - run:
          name: Scan JARs and update Dockerfile
          command: |
            cd workload/mfx-aggre-data-platform/custom_nifi
            python3 << 'PYTHON_SCRIPT'
            import os
            import json
            from pathlib import Path
            
            def scan_jars_folder(jars_folder):
                """Scan JARs folder for manifest files"""
                requested_jars = {}
                jars_path = Path(jars_folder)
                
                if not jars_path.exists():
                    print(f"JARs folder not found: {jars_folder}")
                    return requested_jars
                
                for manifest_file in jars_path.glob("*.json"):
                    try:
                        with open(manifest_file, 'r') as f:
                            manifest = json.load(f)
                        
                        jar_name = manifest.get('name')
                        if jar_name:
                            requested_jars[jar_name] = {
                                'url': manifest.get('url'),
                                'install_path': manifest.get('install_path', '/opt/nifi/nifi-current/lib/'),
                                'description': manifest.get('description', '')
                            }
                    except json.JSONDecodeError as e:
                        print(f"Error parsing {manifest_file}: {e}")
                
                return requested_jars
            
            def generate_dockerfile_additions(jars_dict):
                """Generate RUN commands for downloading JARs"""
                additions = []
                
                for jar_name, jar_info in jars_dict.items():
                    url = jar_info['url']
                    install_path = jar_info['install_path'].rstrip('/')
                    description = jar_info.get('description', jar_name)
                    full_path = f"{install_path}/{jar_name}"
                    
                    addition = f"""
            # Download {description}
            RUN curl -L "{url}" \\
                    -o {full_path} && \\
                    chown 1000:1000 {full_path}
            """
                    additions.append(addition)
                
                return '\n'.join(additions)
            
            def update_dockerfile(dockerfile_path, jars_folder):
                """Update Dockerfile with JAR download commands"""
                # Scan for JARs
                requested_jars = scan_jars_folder(jars_folder)
                
                if not requested_jars:
                    print("No JARs found to add")
                    return
                
                print(f"Found {len(requested_jars)} JARs to add:")
                for jar_name in requested_jars:
                    print(f"  - {jar_name}")
                
                # Read current Dockerfile
                with open(dockerfile_path, 'r') as f:
                    content = f.read()
                
                # Generate additions
                additions = generate_dockerfile_additions(requested_jars)
                
                # Find insertion point (before USER 1000 or marker)
                if '# NEW JARS WILL BE ADDED AUTOMATICALLY ABOVE THIS LINE' in content:
                    # Insert before marker
                    marker = '# NEW JARS WILL BE ADDED AUTOMATICALLY ABOVE THIS LINE'
                    content = content.replace(marker, f"{additions}\n{marker}")
                elif 'USER 1000' in content:
                    # Insert before USER 1000
                    lines = content.split('\n')
                    insert_index = next((i for i, line in enumerate(lines) if 'USER 1000' in line), len(lines))
                    lines.insert(insert_index, additions)
                    content = '\n'.join(lines)
                else:
                    # Append at the end
                    content += '\n' + additions
                
                # Write updated Dockerfile
                with open(dockerfile_path, 'w') as f:
                    f.write(content)
                
                print(f"✅ Updated Dockerfile with {len(requested_jars)} JAR(s)")
            
            # Main execution
            dockerfile_path = 'Dockerfile'
            jars_folder = 'jars'
            update_dockerfile(dockerfile_path, jars_folder)
            PYTHON_SCRIPT

      - setup_remote_docker:
          version: 20.10.24
          docker_layer_caching: true
      
      - aws-cli/setup:
          region: AWS_REGION
          aws_access_key_id: AWS_ACCESS_KEY_ID
          aws_secret_access_key: AWS_SECRET_ACCESS_KEY
      
      - run:
          name: Build and Push to ECR
          command: |
            # Login to ECR
            aws ecr get-login-password --region ${AWS_REGION} | \
              docker login --username AWS --password-stdin \
              ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
            
            # Build image
            cd workload/mfx-aggre-data-platform/custom_nifi
            IMAGE_TAG="${CIRCLE_SHA1:0:7}"
            ECR_REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/apache-nifi-with-custom-jars-repo"
            
            echo "Building Docker image with dynamically added JARs..."
            docker build -t ${ECR_REPO}:${IMAGE_TAG} .
            docker tag ${ECR_REPO}:${IMAGE_TAG} ${ECR_REPO}:latest
            
            # Push to ECR
            docker push ${ECR_REPO}:${IMAGE_TAG}
            docker push ${ECR_REPO}:latest
            
            # Save tag for next job
            echo "${IMAGE_TAG}" > /tmp/image-tag.txt
            
            echo "✅ Docker image built and pushed with custom JARs"
      
      - persist_to_workspace:
          root: /tmp
          paths:
            - image-tag.txt

  create-task-definition-pr:
    executor: python-executor
    steps:
      - checkout
      - attach_workspace:
          at: /tmp

      - run:
          name: Install dependencies
          command: pip install PyGithub
      - run:
          name: Create PR to update task definition
          command: python scripts/update_task_definition.py
          environment:
            TASK_DEF_PATH: workload/mfx-aggre-data-platform/ecs_task_definition.tf
            TARGET_BRANCH: main
            CIRCLE_PROJECT_USERNAME: medalizaidi
            CIRCLE_PROJECT_REPONAME: nifi-jar-automation-option2

workflows:
  version: 2

  scan-and-build:
    jobs:
      # Step 1: Scan JARs and create Dockerfile PR (for version control/documentation)
      - scan-jars-and-create-dockerfile-pr:
          filters:
            branches:
              only: main
          context:
            - github-context

      # Step 2: Manual approval - requires user to approve before continuing
      - hold-for-approval:
          type: approval
          requires:
            - scan-jars-and-create-dockerfile-pr

      # Step 3: Build and push Docker image (with dynamic JAR addition)
      - build-and-push-image:
          requires:
            - hold-for-approval
          filters:
            branches:
              only: main
          context:
            - aws-context

      # Step 4: Create task definition PR
      - create-task-definition-pr:
          requires:
            - build-and-push-image
          filters:
            branches:
              only: main
          context:
            - github-context
            - aws-context